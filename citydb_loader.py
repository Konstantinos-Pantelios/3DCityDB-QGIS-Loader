# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DBLoader
                                 A QGIS plugin
                    This is an experimental plugin for 3DCityDB.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-30
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Konstantinos Pantelios
        email                : konstantinospantelios@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


import os.path
import typing

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QWidget
from qgis.core import QgsCoordinateReferenceSystem, QgsRectangle
from qgis.core import QgsWkbTypes
from qgis.gui import QgisInterface, QgsMapCanvas, QgsRubberBand
import psycopg2

from .resources import qInitResources
from .citydb_loader_dialog import DBLoaderDialog # Main dialog
from .citydb_loader_administration_dialog import AdministrationDialog # Admin dialog
from .main import connection
from .main import constants as c
from .main.proc_functions import sql
from .main.widget_setup import ws_userconn_tab as usr_setup
from .main.widget_setup import ws_layers_tab as lrs_setup
from .main.widget_setup import ws_dbadmin_tab as dba_setup
from .main.widget_setup import widget_reset


class DBLoader:
    """QGIS Plugin Implementation. Main class."""

    plugin_package = c.MAIN_PKG_NAME

    def __init__(self, iface: QgisInterface) -> None:
        """DBLoader class Constructor.

        *   :param iface: An interface instance that will be passed to this
                class which provides the hook by which you can manipulate the
                QGIS application at run time.

            :type iface: QgsInterface
        """
        # Initialize Qt resources from file resources.py.
        qInitResources()

        # Variable to store the main dialog of the plugin.
        self.dlg = None
        # Variable to store the admin dialog of the plugin.
        self.dlg_admin = None

        # Variable to store the existing connection object.
        self.DB: connection.Connection = None

        # Variable to store the selected citydb schema name.
        self.SCHEMA: str = None
        
        # Variable to store the selected user schema name.
        self.USER_SCHEMA: str = c.USER_PKG_NAME

        # Variable to store the selected extents.
        self.EXTENTS: QgsRectangle = iface.mapCanvas().extent()
        # Variable to store the selected crs.
        self.CRS: QgsCoordinateReferenceSystem
        self.CRS = iface.mapCanvas().mapSettings().destinationCrs()

        # Variable to store the citydb schema's extents.
        self.SCHEMA_EXTENTS: QgsRectangle = iface.mapCanvas().extent()
        # Variable to store the mat views extents.
        self.VIEWS_EXTENTS: QgsRectangle = iface.mapCanvas().extent()

        # Variable to store an additional canvas (to show the extents).
        self.CANVAS_C: QgsMapCanvas = QgsMapCanvas()
        self.CANVAS_C.enableAntiAliasing(True)
        self.CANVAS_C.setMinimumWidth(300)
        self.CANVAS_C.setMaximumHeight(350)

        # Variable to store an additional canvas (to show the extents).
        self.CANVAS: QgsMapCanvas = QgsMapCanvas()
        self.CANVAS.enableAntiAliasing(True)
        self.CANVAS.setMinimumWidth(300)
        self.CANVAS.setMaximumHeight(350)

        # Variable to store a rubberband formed by the current extents.
        self.RUBBER_SCHEMA = QgsRubberBand(self.CANVAS, QgsWkbTypes.PolygonGeometry)
        self.RUBBER_LAYERS = QgsRubberBand(self.CANVAS, QgsWkbTypes.PolygonGeometry)
        self.RUBBER_USER = QgsRubberBand(self.CANVAS, QgsWkbTypes.PolygonGeometry)

        # Variable to store a rubberband formed by the current extents.
        self.RUBBER_SCHEMA_C = QgsRubberBand(self.CANVAS_C, QgsWkbTypes.PolygonGeometry)
        self.RUBBER_LAYERS_C = QgsRubberBand(self.CANVAS_C, QgsWkbTypes.PolygonGeometry)

        # Variable to store all availiable FeatureTypes.
        # The availiability is defined by the existance of at least one feature.
        # instance inside the current selected extents (bboox).
        self.FeatureType_container: dict = {}

        # Variable to store the current open connection of a database.
        self.conn: psycopg2.connection = None

        # Variable referencing to the QGIS interface.
        self.iface: QgisInterface = iface

        # initialize plugin directory.
        self.plugin_dir: str = os.path.dirname(__file__) # = PLUGIN_PATH
        # initialize locale.
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            "i18n",
            "DBLoader_{}.qm".format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes.
        self.actions: list = []

        # Check if plugin was started the first time in current QGIS session.
        # Must be set in initGui() to survive plugin reloads.
        self.first_start: bool = True
        self.first_start_admin: bool = True

    def tr(self, message: str ) -> str:
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        *   :param message: String for translation.

            :type message: str

        *   :returns: Translated version of message.

            :rtype: str
        """
        return QCoreApplication.translate("DBLoader", message)

    def add_action(self,
            icon_path: str,
            txt: str,
            callback: typing.Callable[...,None],
            enabled_flag: bool = True,
            add_to_menu: bool = True,
            add_to_toolbar: bool = True,
            status_tip: typing.Optional[str] = None,
            whats_this: typing.Optional[str] = None,
            parent: typing.Optional[QWidget] = None) -> QAction:
        """Add a toolbar icon to the toolbar.

        *   :param icon_path: Path to the icon for this action. Can be a
                resource path (e.g. ":/plugins/foo/bar.png") or a normal
                file system path.

            :type icon_path: str

        *   :param txt: Text that should be shown in menu items for this
                action.

            :type txt: str

        *   :param callback: Function to be called when the action is
                triggered.

            :type callback: function

        *   :param enabled_flag: A flag indicating if the action should be
                enabled by default. Defaults to True.

            :type enabled_flag: bool

        *   :param add_to_menu: Flag indicating whether the action should also
                be added to the menu. Defaults to True.

            :type add_to_menu: bool

        *   :param add_to_toolbar: Flag indicating whether the action should
                also be added to the toolbar. Defaults to True.

            :type add_to_toolbar: bool

        *   :param status_tip: Optional text to show in a popup when mouse
                pointer hovers over the action.

            :type status_tip: str

        *   :param whats_this: Optional text to show in the status bar when the
                mouse pointer hovers over the action.

            :type whats_this: str

        *   :param parent: Parent widget for the new action. Defaults None.

            :type parent: QWidget

        *   :returns: The action that was created. Note that the action is also
                added to self.actions list.

            :rtype: QAction
        """

        # Create icon from referenced path in resources file.
        icon = QIcon(icon_path)

        # Create action object
        action = QAction(icon=icon, text=txt, parent=parent)

        # Signal to run plugin when clicked (execute main method: run())
        action.triggered.connect(callback)

        # Set the name of the action
        action.setObjectName(txt)

        # Set the action as enabled (not grayed out)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(statusTip=status_tip)

        if whats_this is not None:
            action.setWhatsThis(what=whats_this)

        # Adds plugin to "Database" toolbar.
        if add_to_toolbar:
            self.iface.addDatabaseToolBarIcon(qAction=action)

        # Adds plugin to "Database" menu.
        if add_to_menu:
            # In order to add the plugin into the database menu we
            # follow the 'hacky' approach below to bypass possibly a bug:
            #
            # The bug: Using the method addPluginToDatabaseMenu causes
            # the plugin to be inserted in a submenu of itself
            # 3DCityDB-Loader > 3DCityDB-Loader which we don't want.
            # However using the addAction method to insert the plugin directly,
            # causes the database menu to 'pop out' of the menu ribbon in a
            # hidden state. Note that this method, for some bizarre reason,
            # works for all the menus except the database menu.
            # Using the addPluginToDatabaseMenu method BEFORE the addAction
            # method seems to bypass this issue. Needs further investigation.

            # Add the action to the database menu (bug countermeasure)
            self.iface.addPluginToDatabaseMenu(name=c.PLUGIN_NAME, action=action)

            # Add the action to the database menu
            #self.iface.databaseMenu().addAction(action)

            # #Now that we made sure that the bug didn't occure, remove it.
            # self.iface.removePluginDatabaseMenu(name=txt,action=action)

        self.actions.append(action)

        return action

    def initGui(self) -> None:
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # User plugin
        # The icon path is set from the compiled resources file (in main dir).
        icon_path = ":/plugins/citydb_loader/icons/plugin_icon.png"
        self.add_action(
            icon_path=icon_path,
            txt=self.tr(c.PLUGIN_NAME),
            callback=self.run,
            parent=self.iface.mainWindow())


        # Admin plugin
        self.add_action(
            icon_path=icon_path,
            txt=self.tr(c.PLUGIN_NAME_ADMIN),
            callback=self.run_admin,
            parent=self.iface.mainWindow(),
            add_to_toolbar=False)

        # Will be set False in run(), run_admin()
        self.first_start = True
        self.first_start_admin = True

    def unload(self) -> None:
        """Removes the plugin menu item and icon from QGIS GUI."""

        for action in self.actions:
            self.iface.removeDatabaseToolBarIcon(qAction=action)
            self.iface.removePluginDatabaseMenu(name=c.PLUGIN_NAME,action=action)


    def run_admin(self) -> None:
        # Only create GUI ONCE in callback,
        # so that it will only load when the plugin is started.
        if self.first_start_admin:
            self.first_start_admin = False

            # Create the dialog with elements (after translation).
            self.dlg_admin = AdministrationDialog()

        #----------################################################################
        #-SIGNALS--################################################################
        #-(start)--################################################################


            # 'Connection' group box signals (in 'Database Admin' tab)
            self.dlg_admin.cbxExistingConn.currentIndexChanged.connect(
                self.evt_cbxExistingConn_changed)
            self.dlg_admin.btnNewConn.clicked.connect(self.evt_btnNewConn_clicked)
            self.dlg_admin.btnConnectToDb.clicked.connect(self.evt_btnConnectToDb_clicked)


            # 'Main Installation' group box signals (in 'Database Admin' tab)
            self.dlg_admin.btnMainInst.clicked.connect(
                self.evt_btnMainInst_clicked)
            self.dlg_admin.btnMainUninst.clicked.connect(
                self.evt_btnMainUninst_clicked)

            # 'User Installation' group box signals (in 'Database Admin' tab)
            self.dlg_admin.cbxUser.currentIndexChanged.connect(
                self.evt_cbxUser_changed)
            self.dlg_admin.btnUsrInst.clicked.connect(
                self.evt_btnUsrInst_clicked)
            self.dlg_admin.btnUsrUninst.clicked.connect(
                self.evt_btnUsrUninst_clicked)
        
            self.dlg_admin.btnCloseConn.clicked.connect(
                self.evt_btnCloseConn_clicked)

    #----------################################################################
    #-SIGNALS--################################################################
    #--(end)---################################################################

        # Get existing connections from QGIS profile settings.
        connection.get_postgres_conn(self) # Stored in self.conn

        # When this dialogue is open, inputs in any other windows are blocked.
        self.dlg_admin.setWindowModality(2)

        # Show the dialog
        self.dlg_admin.show()

        # Run the dialog event loop.
        res = self.dlg_admin.exec_()
        if not res: # Dialog has closed (X button was pressed)
            # Reset the dialog widgets. (Closes the current open connection.)
            widget_reset.reset_tabDbAdmin(self)



    def run(self) -> None:
        """Run main method that performs all the real work.

        -   Creates the plugin's dialogs
        -   Instantiates the plugin's main class (DBLoaderDialog) with its guis
        -   Setups the plugin's signals
        -   Exectutes the main dialog
        """

        # Only create GUI ONCE in callback,
        # so that it will only load when the plugin is started.
        if self.first_start:
            self.first_start = False

            # Create the dialog with elements (after translation).
            self.dlg = DBLoaderDialog()

    #----------################################################################
    #-SIGNALS--################################################################
    #-(start)--################################################################

            # 'Connection' group box signals (in 'User Connection' tab)
            self.dlg.cbxExistingConnC.currentIndexChanged.connect(
                self.evt_cbxExistingConnC_changed)
            self.dlg.btnNewConnC.clicked.connect(
                self.evt_btnNewConnC_clicked)

            # 'Database' group box signals (in 'User Connection' tab)
            self.dlg.btnConnectToDbC.clicked.connect(
                self.evt_btnConnectToDbC_clicked)
            self.dlg.cbxSchema.currentIndexChanged.connect(
                self.evt_cbxSchema_changed)

            # Basemap (OSM) group box signals (in 'User Connection' tab)

            # Link the addition canvas to the extents qgroupbox and
            # enable "MapCanvasExtent" options (Byproduct).
            self.dlg.qgbxExtentsC.setMapCanvas(canvas=self.CANVAS_C,
                drawOnCanvasOption = False)
            # Draw on Canvas tool is disabled.
            # Check Note on main>widget_setup>ws_layers_tab.py>qgbxExtents_setup

            self.dlg.qgbxExtentsC.setOutputCrs(outputCrs=self.CRS)


            # 'Extents' groupbox signals (in 'User Connection' tab)
            self.dlg.btnCityExtentsC.clicked.connect(
                self.evt_btnCityExtentsC_clicked)
            self.CANVAS_C.extentsChanged.connect(self.evt_canvas_extChanged)
            self.dlg.qgbxExtentsC.extentChanged.connect(
                self.evt_qgbxExtentsC_extChanged)

            self.dlg.btnCreateLayers.clicked.connect(
                self.evt_btnCreateLayers_clicked)
            self.dlg.btnRefreshLayers.clicked.connect(
                self.evt_btnRefreshLayers_clicked)
            self.dlg.btnDropLayers.clicked.connect(
                self.evt_btnDropLayers_clicked)


            self.dlg.btnCloseConnC.clicked.connect(
                self.evt_btnCloseConnC_clicked)

            # Link the addition canvas to the extents qgroupbox and
            # enable "MapCanvasExtent" options (Byproduct).
            self.dlg.qgbxExtents.setMapCanvas(canvas=self.CANVAS,
                drawOnCanvasOption = False)
            # Draw on Canvas tool is disabled.
            # Check Note on main>widget_setup>ws_layers_tab.py>qgbxExtents_setup
            self.dlg.qgbxExtents.setOutputCrs(outputCrs=self.CRS)

            # 'Extents' groupbox signals (in 'Layers' tab)
            self.dlg.qgbxExtents.extentChanged.connect(
                self.evt_qgbxExtents_extChanged)
            self.dlg.btnCityExtents.clicked.connect(
                self.evt_btnCityExtents_clicked)
                

            # 'Parameters' groupbox signals (in 'Layers' tab)
            self.dlg.cbxFeatureType.currentIndexChanged.connect(
                self.evt_cbxFeatureType_changed)
            self.dlg.cbxLod.currentIndexChanged.connect(
                self.evt_cbxLod_changed)

            # 'Features to Import' groupbox signals (in 'Layers' tab)
            self.dlg.ccbxFeatures.checkedItemsChanged.connect(
                self.evt_ccbxFeatures_changed)
            self.dlg.btnImport.clicked.connect(
                self.evt_btnImport_clicked)
            

    #----------################################################################
    #-SIGNALS--################################################################
    #--(end)---################################################################




            #self.dlg.gLayoutBasemapC.itemAtPosition(1,1).widget()

            # Move canvas widget in the layout containing the extents.


            #self.dlg.gLayoutBasemapC.addWidget(self.CANVAS,1,1)
            #self.dlg.vLayoutBasemap.addWidget(self.CANVAS)
            # Replace empty graphics view widget with Map canvas.
            self.dlg.vLayoutBasemap.replaceWidget(self.dlg.gvCanvas, self.CANVAS)
            self.dlg.gLayoutBasemapC.replaceWidget(self.dlg.gvCanvasC, self.CANVAS_C)

            # Remove empty graphics View widget from dialog.
            self.dlg.gvCanvasC.setParent(None)
            self.dlg.gvCanvas.setParent(None)

            #widget_setup.CANVAS_setup(self)

            #print(self.CANVAS, self.dlg.gvCanvas)
            #print(self.dlg.gLayoutBasemapC.itemAtPosition(1,1).widget())

            # Get existing connections from QGIS profile settings.
            connection.get_postgres_conn(self) # Stored in self.conn

        # Show the dialog
        self.dlg.show()

        # Run the dialog event loop.
        res = self.dlg.exec_()
        if not res:
            return None

    #----------################################################################
    #--EVENTS--################################################################
    #-(start)--################################################################

    # 'Connection' group box events (in 'User Connection' tab)
    def evt_cbxExistingConnC_changed(self) -> None:
        """Event that is called when the 'Existing Connection'
        comboBox (cbxExistingConnC) current index changes.
        """

        # Set the current database connection object variable
        self.DB = self.dlg.cbxExistingConnC.currentData()
        if not self.DB:
            return None

        usr_setup.cbxExistingConnC_setup(self)

    def evt_btnNewConnC_clicked(self) -> None:
        """Event that is called when the 'New Connection' pushButton
        (btnNewConnC) is pressed.

        Resposible to add VALID new connection to the 'Existing connections'.
        """

        # Create/Show/Execture additional dialog for the new connection
        dlgConnector = connection.DlgConnector()
        dlgConnector.setWindowModality(2)
        dlgConnector.show()
        dlgConnector.exec_()

        # Add new connection to the Existing connections
        if dlgConnector.new_connection:
            self.dlg.cbxExistingConnC.addItem(
                f"{dlgConnector.new_connection.connection_name}",
                dlgConnector.new_connection)
#            dlgConnector.close()

    # 'Database' group box events (in 'Connection' tab)
    def evt_btnConnectToDbC_clicked(self) -> None:
        """Event that is called when the current 'Connect to {db}' pushButton
        (btnConnectToDbC) is pressed.
        """

        usr_setup.btnConnectToDbC_setup(self)

    def evt_cbxSchema_changed(self) -> None:
        """Event that is called when the 'schemas' comboBox (cbxSchema)
        current index chages.

        Checks if the connection + schema meet the necessary requirements.
        """

        # Set the current schema variable
        self.SCHEMA = self.dlg.cbxSchema.currentText()

        usr_setup.cbxSchema_setup(self)

        # We can proceed ONLY if the necessary requirements are met.
        if self.DB.meets_requirements():
            self.dlg.tabLayers.setDisabled(False)
        else:
            widget_reset.reset_tabLayers(self)
            self.dlg.tabLayers.setDisabled(True)

    # 'Basemap (OSM)' group box events (in 'User Connection' tab)
    def evt_canvas_extChanged(self) -> None:
        """Event that is called when the current canvas extents (pan over map)
        changes.

        Reads the new current extents from the map and sets it in the 'Extents'
        (qgbxExtentsC) widget.
        """

        # Get canvas's current extent
        extent: QgsRectangle = self.CANVAS_C.extent()

        # Set the current extent to show in the 'extent' widget.
        self.dlg.qgbxExtentsC.setCurrentExtent(
            currentExtent=extent,
            currentCrs=self.CRS)
        self.dlg.qgbxExtentsC.setOutputCrs(outputCrs=self.CRS)

    def evt_qgbxExtentsC_extChanged(self) -> None:
        """Event that is called when the 'Extents' groubBox (qgbxExtentsC)
        extent in widget changes.
        """

        usr_setup.qgbxExtentsC_setup(self)

    def evt_btnCityExtentsC_clicked(self) -> None:
        """Event that is called when the current 'Calculate from City model'
        pushButton (btnCityExtentsC) is pressed.
        """

        usr_setup.btnCityExtentsC_setup(self)


    def evt_btnCreateLayers_clicked(self) -> None:
        """Event that is called when the 'Create layers for schema {sch}'
        pushButton (btnCreateLayers) is pressed.
        """

        usr_setup.btnCreateLayers_setup(self)

    def evt_btnRefreshLayers_clicked(self) -> None:
        """Event that is called when the 'Refresh layers for schema {sch}'
        pushButton (btnRefreshLayers) is pressed.
        """

        usr_setup.btnRefreshLayers_setup(self)

    def evt_btnDropLayers_clicked(self) -> None:
        """Event that is called when the 'Drop layers for schema {sch}'
        pushButton (btnRefreshLayers) is pressed.
        """

        usr_setup.btnDropLayers_setup(self)

    def evt_update_bar(self,dialog,step,text) -> None:
        """Function to setup the progress bar upon update.
        Important: Progress Bar need to be already created
        in dbLoader.msg_bar: QgsMessageBar and
        dbLoader.bar: QProgressBar.

        *   :param dialog: The dialog to hold the bar.
            "admin" or "main"

            :type step: str

        *   :param step: Current value of the progress

            :type step: int

        *   :param text: Text to display on the bar

            :type text: str

        .. This event is not linked to any widet_setup function
        .. as it isn't responsible for changes in different
        .. widgets in the gui.
        """

        if dialog == "admin":
            progress_bar = self.dlg_admin.bar
        elif dialog == "main":
            progress_bar = self.dlg.bar

        # Show text instead of completed percentage.
        if text:
            progress_bar.setFormat(text)
        # Update progress with current step
        progress_bar.setValue(step)

    def evt_btnCloseConnC_clicked(self) -> None:
        """Event that is called when the 'Close current connection' pushButton
        (btnCloseConn) is pressed.
        """

        widget_reset.reset_tabConnection(self)
        widget_reset.reset_tabLayers(self)


    # 'Parameters' group box events (in 'Import' tab)
    def evt_qgbxExtents_extChanged(self) -> None:
        """Event that is called when the 'Extents' groubBox (qgbxExtents)
        extent changes.
        """

        lrs_setup.qgbxExtents_setup(self)

    def evt_btnCityExtents_clicked(self) -> None:
        """Event that is called when the current 'Set to layers extents'
        pushButton (btnCityExtents) is pressed.
        """

        lrs_setup.btnCityExtents_setup(self)

    def evt_cbxFeatureType_changed(self) -> None:
        """Event that is called when the 'Feature Type'comboBox (cbxFeatureType)
        current index chages.
        """

        lrs_setup.cbxFeatureType_setup(self)

    def evt_cbxLod_changed(self) -> None:
        """Event that is called when the 'Geometry Level'comboBox (cbxLod)
        current index chages.
        """

        lrs_setup.cbxLod_setup(self)

    # 'Features to Import' group box events (in 'Import' tab)
    def evt_ccbxFeatures_changed(self) -> None:
        """Event that is called when the 'Availiable Features'
        checkableComboBox (ccbxFeatures) current index chages.
        """

        lrs_setup.ccbxFeatures_setup(self)

    def evt_btnImport_clicked(self) -> None:
        """Event that is called when the 'Import Features' pushButton
        (btnImport) is pressed.
        """

        lrs_setup.btnImport_setup(self)
        # Here is the final step.
        # Meaning that user did everything and can now close
        # the window to continue working outside the plugin.

    # 'Connection' group box events (in 'Database Administration' tab)
    def evt_cbxExistingConn_changed(self) -> None:
        """Event that is called when the 'Existing Connection'
        comboBox (cbxExistingConn) current index changes.
        """
        # Set the current database connection object variable
        self.DB = self.dlg_admin.cbxExistingConn.currentData()
        if not self.DB:
            return None

        dba_setup.cbxExistingConn_setup(self)
        
    def evt_btnNewConn_clicked(self) -> None:
        """Event that is called when the 'New Connection' pushButton
        (btnNewConn) is pressed.

        Resposible to add VALID new connection to the 'Existing connections'.
        """
        # Bypass the input blockade for the connector dialogue.
        self.dlg_admin.setWindowModality(1)


        # Create/Show/Execture additional dialog for the new connection
        dlgConnector = connection.DlgConnector()
        dlgConnector.setWindowModality(2)
        dlgConnector.show()
        dlgConnector.exec_()

        # Add new connection to the Existing connections
        if dlgConnector.new_connection:
            self.dlg_admin.cbxExistingConn.addItem(
                f"{dlgConnector.new_connection.connection_name}",
                dlgConnector.new_connection)
#            dlgConnector.close()

        # Reinstage the input blockage.
        self.dlg_admin.setWindowModality(2)

    def evt_btnConnectToDb_clicked(self) -> None:
        """Event that is called when the current 'Connect to {db}' pushButton
        (btnConnectToDb) is pressed.
        """

        dba_setup.btnConnectToDb_setup(self)

    def evt_cbxUser_changed(self) -> None:
        """Event that is called when the 'Selected User'
        comboBox (cbxUser) current index changes.
        """

        dba_setup.cbxUser_setup(self)

    # 'Installation' group box events (in 'Database Administration' tab)
    def evt_btnMainInst_clicked(self) -> None:
        """Event that is called when the 'Install to database' pushButton
        (btnMainInst) is pressed.
        """

        dba_setup.btnMainInst_setup(self)

    def evt_btnMainUninst_clicked(self) -> None:
        """Event that is called when the 'Uninstall from database' pushButton
        (btnMainUninst) is pressed.
        """
        dba_setup.btnMainUninst_setup(self)

        # 'Installation' group box events (in 'Database Administration' tab)
    def evt_btnUsrInst_clicked(self) -> None:
        """Event that is called when the 'Create schema for user' pushButton
        (btnUsrInst) is pressed.
        """

        dba_setup.btnUsrInst_setup(self)

    def evt_btnUsrUninst_clicked(self) -> None:
        """Event that is called when the 'Drop schema for user' pushButton
        (btnUsrUninst) is pressed.
        """
        dba_setup.btnUsrUninst_setup(self)   

    def evt_btnCloseConn_clicked(self) -> None:
        """Event that is called when the 'Close current connection' pushButton
        (btnCloseConn) is pressed.
        """

        widget_reset.reset_tabDbAdmin(self)

    #----------################################################################
    #--EVENTS--################################################################
    #--(end)---################################################################


#NOTE: extent groupbox doesnt work for manual user input
#for every value change in any of the 4 inputs the extent signal is emited
